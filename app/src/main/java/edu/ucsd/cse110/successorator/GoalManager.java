package edu.ucsd.cse110.successorator;

import android.content.SharedPreferences;

import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;
import java.util.Calendar;

public class GoalManager {
    private SharedPreferences sharedPreferences;
    private static final int HOURS_DAY = 24;
    private static final int MINS_HOUR = 60;
    private static final int SECONDS_MIN = 60;
    private static final int MILLIS_SECOND = 1000;
    private static final int TIME_TO_DELETE = 2;

    public GoalManager(SharedPreferences sharedPreferences) {
        this.sharedPreferences = sharedPreferences;
    }

    private LocalDate executedLocalDate(long lastExecutionTimestamp) {
        //Code generated by ChatGPT to transfer timestamp to LocalDate
        Instant instant = Instant.ofEpochMilli(lastExecutionTimestamp);
        LocalDate localDate = instant.atZone(ZoneId.systemDefault()).toLocalDate();
        return localDate;
    }

    private Calendar getExecutedCalendar(long lastExecutionTimestamp) {
        Calendar lastExecutionCalendar = Calendar.getInstance();
        lastExecutionCalendar.setTimeInMillis(lastExecutionTimestamp);
        return lastExecutionCalendar;
    }

    private boolean executedDayBefore(long lastExecutionTimestamp) {
        LocalDate executedDate = executedLocalDate(lastExecutionTimestamp);
        LocalDate currentDate = LocalDate.now();
        return executedDate.isBefore(currentDate);
    }

    private long executedDaysBefore(long lastExecutionTimestamp) {
        LocalDate executedDate = executedLocalDate(lastExecutionTimestamp);
        LocalDate currentDate = LocalDate.now();

        long daysDifference = ChronoUnit.DAYS.between(executedDate, currentDate);
        return daysDifference;
    }

    private int executedDateDiff(long lastExecutionTimestamp) {
        int lastExecutedDate = getExecutedCalendar(lastExecutionTimestamp)
                                    .get(Calendar.DAY_OF_YEAR);

        Calendar currentCalendar = Calendar.getInstance();
        int currentDate = currentCalendar.get(Calendar.DAY_OF_YEAR);

        int dateDiff = currentDate - lastExecutedDate;
        return dateDiff;
    }

    private boolean executedBefore2AM(long lastExecutionTimestamp) {
        int lastExecutedHour = getExecutedCalendar(lastExecutionTimestamp)
                                    .get(Calendar.HOUR_OF_DAY);
        return lastExecutedHour < TIME_TO_DELETE;
    }

    private boolean currentBefore2AM() {
        Calendar currentCalendar = Calendar.getInstance();
        int currentHour = currentCalendar.get(Calendar.HOUR_OF_DAY);
        return currentHour < TIME_TO_DELETE;
    }

    public boolean deleteCrossedGoalsNotExecutedToday() {
        long executedTime = sharedPreferences.getLong("lastExecution", 0L);

        LocalDate executedDate = executedLocalDate(executedTime);
        LocalDate currentDate = LocalDate.now();

        if (executedBefore2AM(executedTime)) {
            return !currentBefore2AM() || executedDate.isBefore(currentDate);
        } else {
            return (currentBefore2AM() && (executedDaysBefore(executedTime) > 1)) ||
                    (!currentBefore2AM() && executedDate.isBefore(currentDate));
        }
    }

    public void executeDeleteCrossedGoals() {
        // Get the GoalRepository stored in dataset here and call deleteCrossedGoals()


        // Update the flag to indicate execution
        long executionTimeStamp = System.currentTimeMillis();
        sharedPreferences.edit().putLong("lastExecution", executionTimeStamp).apply();
    }
}
